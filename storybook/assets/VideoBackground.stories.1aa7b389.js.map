{"version":3,"file":"VideoBackground.stories.1aa7b389.js","sources":["../../node_modules/.pnpm/intervalometer@1.0.5/node_modules/intervalometer/dist/intervalometer.es-modules.js","../../node_modules/.pnpm/iphone-inline-video@2.2.2/node_modules/iphone-inline-video/dist/iphone-inline-video.es-modules.js","../../src/components/VideoBackground/VideoBackground.jsx"],"sourcesContent":["/*! npm.im/intervalometer */\nfunction intervalometer(cb, request, cancel, requestParameter) {\n\tvar requestId;\n\tvar previousLoopTime;\n\tfunction loop(now) {\n\t\t// Must be requested before cb() because that might call .stop()\n\t\trequestId = request(loop, requestParameter);\n\n\t\t// Called with \"ms since last call\". 0 on start()\n\t\tcb(now - (previousLoopTime || now));\n\n\t\tpreviousLoopTime = now;\n\t}\n\n\treturn {\n\t\tstart: function start() {\n\t\t\tif (!requestId) { // Prevent double starts\n\t\t\t\tloop(0);\n\t\t\t}\n\t\t},\n\t\tstop: function stop() {\n\t\t\tcancel(requestId);\n\t\t\trequestId = null;\n\t\t\tpreviousLoopTime = 0;\n\t\t}\n\t};\n}\n\nfunction frameIntervalometer(cb) {\n\treturn intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);\n}\n\nfunction timerIntervalometer(cb, delay) {\n\treturn intervalometer(cb, setTimeout, clearTimeout, delay);\n}\n\nexport { intervalometer, frameIntervalometer, timerIntervalometer };","/*! npm.im/iphone-inline-video 2.2.2 */\nimport { frameIntervalometer } from 'intervalometer';\n\nfunction preventEvent(element, eventName, test) {\n\tfunction handler(e) {\n\t\tif (!test || test(element, eventName)) {\n\t\t\te.stopImmediatePropagation();\n\t\t\t// // console.log(eventName, 'prevented on', element);\n\t\t}\n\t}\n\telement.addEventListener(eventName, handler);\n\n\t// Return handler to allow to disable the prevention. Usage:\n\t// const preventionHandler = preventEvent(el, 'click');\n\t// el.removeEventHandler('click', preventionHandler);\n\treturn handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\tfunction get() {\n\t\treturn sourceObject[propertyName];\n\t}\n\tfunction set(value) {\n\t\tsourceObject[propertyName] = value;\n\t}\n\n\tif (copyFirst) {\n\t\tset(object[propertyName]);\n\t}\n\n\tObject.defineProperty(object, propertyName, {get: get, set: set});\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n}\n\nfunction dispatchEventAsync(element, type) {\n\tPromise.resolve().then(function () {\n\t\telement.dispatchEvent(new Event(type));\n\t});\n}\n\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\n\nvar IIV = 'bfred-it:iphone-inline-video';\nvar IIVEvent = 'bfred-it:iphone-inline-video:event';\nvar IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';\nvar IIVPause = 'bfred-it:iphone-inline-video:nativepause';\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n\tvar audio = new Audio();\n\tproxyEvent(video, 'play', audio);\n\tproxyEvent(video, 'playing', audio);\n\tproxyEvent(video, 'pause', audio);\n\taudio.crossOrigin = video.crossOrigin;\n\n\t// 'data:' causes audio.networkState > 0\n\t// which then allows to keep <audio> in a resumable playing state\n\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\taudio.src = video.src || video.currentSrc || 'data:';\n\n\t// // if (audio.src === 'data:') {\n\t//   TODO: wait for video to be selected\n\t// // }\n\treturn audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n\t// Allow one timeupdate event every 200+ ms\n\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\tvideo[IIVEvent] = true;\n\t\tlastTimeupdateEvent = Date.now();\n\t}\n\tif (!rememberOnly) {\n\t\tvideo.currentTime = time;\n\t}\n\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n\treturn player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n\tvar player = this;\n\t// // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\tif (!player.hasAudio) {\n\t\t\tplayer.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);\n\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t}\n\t\t}\n\t\tsetTime(player.video, player.driver.currentTime);\n\t} else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n\t\t// This should happen when the source is available but:\n\t\t// - it's potentially playing (.paused === false)\n\t\t// - it's not ready to play\n\t\t// - it's not loading\n\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\tplayer.video.load();\n\t\t// // console.log('Will load');\n\t}\n\n\t// // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\tif (player.video.ended) {\n\t\tdelete player.video[IIVEvent]; // Allow timeupdate event\n\t\tplayer.video.pause(true);\n\t}\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n\t// // console.log('play');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\t// If it's fullscreen, use the native player\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPlay]();\n\t\treturn;\n\t}\n\n\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t// // console.log('src changed on play', video.src);\n\t\tsetTime(video, 0, true);\n\t\tplayer.driver.src = video.src;\n\t}\n\n\tif (!video.paused) {\n\t\treturn;\n\t}\n\tplayer.paused = false;\n\n\tif (video.buffered.length === 0) {\n\t\t// .load() causes the emptied event\n\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t// possibly the alternative is preventing this event only once\n\t\tvideo.load();\n\t}\n\n\tplayer.driver.play();\n\tplayer.updater.start();\n\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'play');\n\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t// // console.log('onplay');\n\t\t\tdispatchEventAsync(video, 'playing');\n\t\t}\n\t}\n}\nfunction pause(forceEvents) {\n\t// // console.log('pause');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\tplayer.driver.pause();\n\tplayer.updater.stop();\n\n\t// If it's fullscreen, the developer the native player.pause()\n\t// This is at the end of pause() because it also\n\t// needs to make sure that the simulation is paused\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPause]();\n\t}\n\n\tif (player.paused && !forceEvents) {\n\t\treturn;\n\t}\n\n\tplayer.paused = true;\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'pause');\n\t}\n\n\t// Handle the 'ended' event only if it's not fullscreen\n\tif (video.ended && !video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVEvent] = true;\n\t\tdispatchEventAsync(video, 'ended');\n\t}\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n\tvar player = {};\n\tvideo[IIV] = player;\n\tplayer.paused = true; // Track whether 'pause' events have been fired\n\tplayer.hasAudio = hasAudio;\n\tplayer.video = video;\n\tplayer.updater = frameIntervalometer(update.bind(player));\n\n\tif (hasAudio) {\n\t\tplayer.driver = getAudioFromVideo(video);\n\t} else {\n\t\tvideo.addEventListener('canplay', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// // console.log('oncanplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t});\n\t\tplayer.driver = {\n\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\tmuted: true,\n\t\t\tpaused: true,\n\t\t\tpause: function () {\n\t\t\t\tplayer.driver.paused = true;\n\t\t\t},\n\t\t\tplay: function () {\n\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t// Media automatically goes to 0 if .play() is called when it's done\n\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget ended() {\n\t\t\t\treturn isPlayerEnded(player);\n\t\t\t}\n\t\t};\n\t}\n\n\t// .load() causes the emptied event\n\tvideo.addEventListener('emptied', function () {\n\t\t// // console.log('driver src is', player.driver.src);\n\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t// // console.log('src changed to', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t\t// Playing videos will only keep playing if no src was present when .play()â€™ed\n\t\t\tif (wasEmpty || (!hasAudio && video.autoplay)) {\n\t\t\t\tplayer.driver.play();\n\t\t\t} else {\n\t\t\t\tplayer.updater.stop();\n\t\t\t}\n\t\t}\n\t}, false);\n\n\t// Stop programmatic player when OS takes over\n\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\tif (!video.paused) {\n\t\t\t// Make sure that the <audio> and the syncer/updater are stopped\n\t\t\tvideo.pause();\n\n\t\t\t// Play video natively\n\t\t\tvideo[IIVPlay]();\n\t\t} else if (hasAudio && player.driver.buffered.length === 0) {\n\t\t\t// If the first play is native,\n\t\t\t// the <audio> needs to be buffered manually\n\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\tplayer.driver.load();\n\t\t}\n\t});\n\tif (hasAudio) {\n\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t// Sync audio to new video position\n\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t// // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t});\n\n\t\t// Allow seeking\n\t\tvideo.addEventListener('seeking', function () {\n\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t// // console.log('User-requested seeking');\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction preventWithPropOrFullscreen(el) {\n\tvar isAllowed = el[IIVEvent];\n\tdelete el[IIVEvent];\n\treturn !el.webkitDisplayingFullscreen && !isAllowed;\n}\n\nfunction overloadAPI(video) {\n\tvar player = video[IIV];\n\tvideo[IIVPlay] = video.play;\n\tvideo[IIVPause] = video.pause;\n\tvideo.play = play;\n\tvideo.pause = pause;\n\tproxyProperty(video, 'paused', player.driver);\n\tproxyProperty(video, 'muted', player.driver, true);\n\tproxyProperty(video, 'playbackRate', player.driver, true);\n\tproxyProperty(video, 'ended', player.driver);\n\tproxyProperty(video, 'loop', player.driver, true);\n\n\t// IIV works by seeking 60 times per second.\n\t// These events are now useless.\n\tpreventEvent(video, 'seeking', function (el) { return !el.webkitDisplayingFullscreen; });\n\tpreventEvent(video, 'seeked', function (el) { return !el.webkitDisplayingFullscreen; });\n\n\t// Limit timeupdate events\n\tpreventEvent(video, 'timeupdate', preventWithPropOrFullscreen);\n\n\t// Prevent occasional native ended events\n\tpreventEvent(video, 'ended', preventWithPropOrFullscreen);\n}\n\nfunction enableInlineVideo(video, opts) {\n\tif ( opts === void 0 ) opts = {};\n\n\t// Stop if already enabled\n\tif (video[IIV]) {\n\t\treturn;\n\t}\n\n\t// Allow the user to skip detection\n\tif (!opts.everywhere) {\n\t\t// Only iOS8 and 9 are supported\n\t\tif (!iOS8or9) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stop if it's not an allowed device\n\t\tif (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Try to pause\n\tvideo.pause();\n\n\t// Prevent autoplay.\n\t// An non-started autoplaying video can't be .pause()'d\n\tvar willAutoplay = video.autoplay;\n\tvideo.autoplay = false;\n\n\taddPlayer(video, !video.muted);\n\toverloadAPI(video);\n\tvideo.classList.add('IIV');\n\n\t// Autoplay\n\tif (video.muted && willAutoplay) {\n\t\tvideo.play();\n\t\tvideo.addEventListener('playing', function restoreAutoplay() {\n\t\t\tvideo.autoplay = true;\n\t\t\tvideo.removeEventListener('playing', restoreAutoplay);\n\t\t});\n\t}\n\n\tif (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t}\n}\n\nexport default enableInlineVideo;\n","/**\n * @file VideoBackground.js\n */\nimport { useState, useEffect, useRef, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { isMobileOnly, isTablet } from 'react-device-detect'\nimport enableInlineVideo from 'iphone-inline-video'\nimport { useLayoutEffect } from '@fomolol/tacklebox'\n\nimport styles from './VideoBackground.module.css'\n\nconst VideoBackground = ({\n  className = 'absolute inset-0 z-0 object-cover w-screen h-screen min-h-screen overflow-hidden min-w-screen mix-blend-normal brightness-125',\n  src = {\n    mobile: '/video/2890361953_mobile',\n    tablet: '/video/2890361919_ipad_768x1024_1',\n    desktop: '/video/2890361919_desktop',\n  },\n  style = {},\n  loop = true,\n  forcePlay = false,\n}) => {\n  const bgVideoRef = useRef()\n  // Desktop by default\n  const [videoUrl, setVideoUrl] = useState(src?.desktop)\n  // Enable iphone-inline-video\n  useEffect(() => {\n    if (bgVideoRef?.current) {\n      enableInlineVideo(bgVideoRef.current, { iPad: true })\n    }\n  }, [videoUrl, bgVideoRef])\n\n  let { mobile, tablet, desktop } = src\n  if (!tablet) {\n    tablet = desktop\n  }\n  const onLoadedData = (e) => {}\n\n  useLayoutEffect(() => {\n    if (isMobileOnly) {\n      setVideoUrl(mobile)\n    }\n    if (isTablet) {\n      setVideoUrl(tablet)\n    }\n  }, [src, desktop, mobile, tablet])\n\n  // if video loops, restart it when the window receives focus\n  // (fixes ios performance \"feature\" which pauses videos when window loses focus)\n  const onFocus = useCallback(() => {\n    if (!bgVideoRef || !bgVideoRef.current) return\n    if (loop) {\n      bgVideoRef.current.play()\n    } //else {\n    //   bgVideoRef.current.currentTime = bgVideoRef.current.duration - 0.1;\n    //   bgVideoRef.current.pause();\n    // }\n  }, [loop])\n\n  // if video does not loop, set the current time to the very end and pause it\n  // when the window loses focus\n  const onBlur = useCallback(() => {\n    if (!bgVideoRef || !bgVideoRef.current) return\n    if (!loop) {\n      bgVideoRef.current.currentTime = bgVideoRef.current.duration - 0.5\n      bgVideoRef.current.pause()\n    }\n  }, [loop])\n\n  useEffect(() => {\n    if (forcePlay) {\n      window.addEventListener('focus', onFocus)\n      window.addEventListener('blur', onBlur)\n    }\n\n    return () => {\n      window.removeEventListener('focus', onFocus)\n      window.removeEventListener('blur', onBlur)\n    }\n  }, [forcePlay, onBlur, onFocus])\n\n  return (\n    <>\n      <video\n        ref={bgVideoRef}\n        playsInline\n        autoPlay\n        muted\n        loop={loop}\n        className={className}\n        style={style}\n        onLoadedData={onLoadedData}\n      >\n        {/* <source src={`${videoUrl}.webm`} type=\"video/webm\" /> */}\n        <source src={`${videoUrl}.mp4`} type=\"video/mp4\" />\n        <p className=\"flex items-center justify-center text-xl text-white max-w-1/2\">\n          Your browser does not support the video tag.\n        </p>\n      </video>\n      <div className=\"absolute inset-0 flex items-center justify-center font-sans\">\n        <p className=\"flex h-[10vw] w-[50vw] flex-col items-center justify-center bg-black text-center leading-none\">\n          <span className=\"text-[7rem] font-black leading-none tracking-widest text-white\">\n            CENSORED\n          </span>\n          <span className=\"text-[1.5rem] font-light tracking-normal text-white/50\">\n            (watermarks)\n          </span>\n        </p>\n      </div>\n    </>\n  )\n}\n\nVideoBackground.propTypes = {\n  src: PropTypes.object,\n  style: PropTypes.object,\n  loop: PropTypes.bool,\n  className: PropTypes.string,\n}\n\nexport default VideoBackground\n"],"names":["intervalometer","cb","request","cancel","requestParameter","requestId","previousLoopTime","loop","now","__name","frameIntervalometer","preventEvent","element","eventName","test","handler","e","proxyProperty","object","propertyName","sourceObject","copyFirst","get","set","value","proxyEvent","dispatchEventAsync","type","iOS8or9","IIV","IIVEvent","IIVPlay","IIVPause","getAudioFromVideo","video","audio","lastRequests","requestIndex","lastTimeupdateEvent","setTime","time","rememberOnly","isPlayerEnded","player","update","timeDiff","play","pause","forceEvents","addPlayer","hasAudio","wasEmpty","preventWithPropOrFullscreen","el","isAllowed","overloadAPI","enableInlineVideo","opts","willAutoplay","restoreAutoplay","VideoBackground","className","src","mobile","tablet","desktop","style","forcePlay","bgVideoRef","useRef","videoUrl","setVideoUrl","useState","useEffect","current","iPad","onLoadedData","useLayoutEffect","isMobileOnly","isTablet","onFocus","useCallback","onBlur","currentTime","duration","addEventListener","removeEventListener","_Fragment","_jsxs","_jsx","propTypes","PropTypes","bool","string","VideoBackground$1"],"mappings":"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"}